#!/usr/bin/env bash
#
# SPDX-License-Identifier: AGPL-3.0

_path="$( \
  export \
    _OLDPWD="$(pwd)" && \
    cd \
      "$(dirname \
           "${BASH_SOURCE[0]}")" && \
    echo\
      "$(pwd)" && \
    cd "${_OLDPWD}")" && \
    unset \
      _OLDPWD

app_name="$( \
  basename \
    "${BASH_SOURCE[0]}")"

_globals() {
  set -e -u
  shopt -s extglob

  # Control the environment
  umask \
    0022
  export \
    LC_ALL="C.UTF-8"
  # LC_ALL=C.UTF-8, unlike LC_ALL=C, does not override LANGUAGE.
  # See https://sourceware.org/bugzilla/show_bug.cgi?id=16621 \
  # and https://savannah.gnu.org/bugs/?62815
  [[ -v LANGUAGE ]] && \
    unset \
      LANGUAGE
  [[ -v SOURCE_DATE_EPOCH ]] || \
    printf \
      -v \
        SOURCE_DATE_EPOCH \
        '%(%s)T' \
        -1
  export \
    SOURCE_DATE_EPOCH
  _override_dev=""
  _override_user=""
  _override_port=""
  _override_verbose=""
  _host=""
  _dev="wlan0"
  _user="dev"
  _port="2222"
  _verbose="false"
}

# Local ssh resolver
# $1: hostname of the device to connect
# $2: network device name
_dynssh() {
  local \
    _host="${1}" \
    _dev="${2}" \
    _user="${3}" \
    _port="${4}" \
    _args=() \
    _msg=() \
    _sshcfg \
    _cfg \
    _hostname \
    _address \
    _ns
  shift \
    4
  _args=(
    "$@")
  _sshcfg="${HOME}/.config/dynssh/ssh.config"
  [[ $(ifconfig \
         -a  | \
         grep \
           "${_dev}") ]] && \
    _address="$( \
      _get_address \
        "${_dev}")"
  [[ "${_address}" == "" ]] && \
      _msg=(
	"${_dev} is not connected"
        "to a network.") && \
      _msg_error \
        "${_msg[*]}" \
        1
  _msg=(
    "${_dev} has address"
    "${_address}")
  _msg_info \
    "${_msg[*]}"
  _ns="$( \
    _get_subnet \
      "${_address}")"
  [[ "$(_confirm_subnet \
          "${_dev}" \
          "${_ns}")" != "" ]] && \
    _msg_error \
      "anomalous behaviour" \
      1
  [[ "${_ns}" == "" ]] && \
    _msg=(
      "${_dev} is not connected"
      "to a network.") && \
    _msg_error \
      "${_msg[*]}" \
      1
  _msg=(
    "${_dev} is on subnet"
    "${_ns}.0")
  _read_conf \
    "${_dev}"
  _hostname="$( \
    echo \
      "${_cfg}" | \
      grep "${_host}=" | \
        awk \
	  -F "=" \
	  '{print $2}')"
  [[ "${_hostname}" == "" ]] && \
    _msg_error \
      "No address configured for ${_host}" \
      1
  _port="$( \
    echo \
      "${_hostname}" | \
      awk \
        -F ":" \
	'{print $2}')"
  _hostname="$( \
    echo \
      "${_hostname}" | \
      awk \
        -F ":" \
	'{print $1}')"
  _msg=(
    "connecting to ${_user}@${_host}:${_port}"
    )
  _msg_info \
    "${_msg[*]}"
  _msg=(
    "args: ${_args[@]}")
  _msg_info \
    "${_msg[*]}"
  _ssh_conf \
    "${_host}" \
    "${_ns}.${_hostname}" \
    "${_user}" \
    "${_port}"
  # _connection_test
  ssh \
    -F "${_sshcfg}" \
    "${_host}" \
    "${_args[@]}"
}

_connection_test() {
  if ssh \
         -q \
         -F "${_sshcfg}" \
         -o StrictHostKeyChecking=no \
         -o ConnectTimeOut=5 \
         "${_host}" \
         'exit 0'; then
    return
  fi
  _msg_error \
    "can't connect to host '${_host}" \
    1
}

# Writes SSH configuration
_ssh_conf() {
  local \
    _host="${1}" \
    _hostname="${2}" \
    _user="${3}" \
    _port="${4}" \
    _out \
    _cfg=()
  _out="${HOME}/.config/dynssh/ssh.config"
  _cfg=(
    "Host ${_host}"
    "  HostName ${_hostname}"
    "  Port ${_port}"
    "  IdentityFile ${HOME}/.ssh/${_host}"
    "  User ${_user}"
  )
  printf \
    '%s\n' \
    "${_cfg[@]}" > \
    "${HOME}/.config/dynssh/ssh.config"
  chmod \
    700 \
    "${_out}"
}

# Get subnet from IPv4 address
# $1: address
_get_subnet() {
  local \
    _address="${1}"
  echo \
    "${_address%.*}"
}

_confirm_subnet() {
  local \
    _dev="${1}" \
    _ns="${2}" \
    _confirm \
    _no_route=()
  _no_route=(
    "INET (IPv4) not configured"
    "in this system.")
  _confirm="$( \
    _get_subnet \
      "$(route | \
           grep \
	     "${_dev}" | \
	     awk \
	       '{print $1}')")"
  [[  "$(route)" == \
      "${_no_route[*]}" ]] && \
    return
  [[ "${_ns}" != \
     "${_confirm}" ]] && \
    echo \
      "ifconfig: ${_ns}" && \
    echo \
      "route: ${_confirm}"
}

_get_address() {
  local \
    _dev="${1}" \
    _line
  _line="$( \
    ifconfig \
      -a | \
      grep \
        -Pn \
        "${_dev}" | \
        cut \
          -d":" \
          -f 1)"
  _line=$(( \
    _line + 1 ))
  ifconfig \
    -a | \
      sed \
        -n "${_line}p;" | \
	awk '{print $2}'
}

_check_conf() {
  local \
    _conf="${1}" \
    _address \
    _dir \
    _host \
    _msg=() \
    _perm
  _dir="${HOME}/.config"
  _conf="${_dir}/${app_name}/localhosts.cfg"
  _msg=(
    "Configuration file:"
    "${_conf}"
  )
  _msg_info \
    "${_msg[*]}"
  if [ ! -e  "${_conf}" ]; then
    _msg_info \
      "$( \
        basename \
          "${_conf}") does not exist"
    mkdir \
      -p \
      "$(dirname \
           "${_conf}")"
    echo \
      "# values go from 2 to 254" >> \
      "${_conf}"
    echo \
      "# device=111" >> \
      "${_conf}"
    _input_credentials
    _address="$( \
      _get_address \
        "${_dev}")"
    echo \
      "${_host}=${_address##*.}:${_port}" >> \
      "${_conf}"
  fi
  _perm="$( \
    stat \
      -c '%a' \
      "${_conf}")"
  if [[ "${_perm}" != "700" ]]; then
    chmod \
      700 \
      "${_conf}"
  fi
}

_input_credentials() {
  echo \
    "enter name for this host:" && \
  while \
    [[ "${_host}" == "" ]]; do
    read \
      _host
  done
  echo \
    "enter port for this host:" && \
  while \
    [[ "${_port}" == "" ]]; do
    read \
      _port
   done
}

_read_conf() {
  local \
    _dev="${1}" \
    _conf \
    _dir \
    _hostname=""
  _dir="${HOME}/.config"
  _conf="${_dir}/${app_name}/localhosts.cfg"
  _check_conf \
    "${_conf}"
  _cfg="$( \
    cat \
      "${_conf}")"
  _cfg="$(\
    echo \
      "${_cfg}" | \
      sed \
        -e "/# */d" | \
	grep \
          "=" )"
  if [[ "${_cfg}" == '' ]]; then
    _msg_error \
      "empty configuration file!" \
      1
  fi
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
    IFS='' read -r -d '' usagetext <<ENDUSAGETEXT || true
usage: ${app_name} [options] <host>
  options:
     -d <device>      Specify network device
                      Default: '${_dev}'
     -u <user>        user to connect to.
                      Default: '${_user}'
     -p <port>        Connect through a specific port.
                      Default: '${_port}'
     -h               This message
     -v               Enable verbose output

  host:               Host to connect to.
ENDUSAGETEXT
    printf \
      '%s' \
      "${usagetext}"
    exit "${1}"
}

_msg_info() {
  local \
    _msg=()
  _msg=(  
    "$@"
  )
  if [[ "${_override_verbose}" == "true" ]]; then
    printf \
      '[%s] INFO: %s\n' \
      "${app_name}" \
      "${_msg[*]}" # >&2
  fi
  return
}

# Show an ERROR message then exit with status
# $1: message string
# $2: exit code number (with 0 does not exit)
_msg_error() {
  local \
    _msg="${1}" \
    _error="${2}"
  printf \
    '[%s] ERROR: %s\n' \
    "${app_name}" \
    "${_msg}" >&2
  if (( _error > 0 )); then
    exit \
      "${_error}"
  fi
}

_globals

while getopts 'd:u:p:v:h?' arg; do
  case "${arg}" in
    d) _override_dev="${OPTARG}" ;;
    u) _override_user="${OPTARG}" ;;
    p) _override_port="${OPTARG}" ;;
    v) _override_verbose="${OPTARG}" ;;
    h|?) _usage 0 ;;
    *)
        _msg_error \
          "Invalid argument '${arg}'" 0
        _usage 0
        ;;
  esac
done

shift $((OPTIND - 1))

if (( $# < 1 )); then
  _msg_error \
    "No host specified." \
    0
  _usage 0
fi

_host="${1}"
shift 1
_args=(
  "$@"
)

[[ "${_override_dev}" == "" ]] && \
  _override_dev="${_dev}" && \
  _msg_info \
    "using default device '${_override_dev}'"

[[ "${_override_user}" == "" ]] || \
[ ! -n "${TERMUX_VERSION}" ] && \
  _override_user="${_user}" && \
  _msg_info \
    "using default user ${_override_user}"

[[ "${_override_port}" == "" ]] && \
  _override_port="${_port}" && \
  _msg_info \
    "using default port ${_override_port}"

_dynssh \
  "${_host}" \
  "${_override_dev}" \
  "${_override_user}" \
  "${_override_port}" \
  "${_args[@]}"

# vim:set sw=2 sts=-1 et:
